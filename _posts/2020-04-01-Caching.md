---
layout: post
title: Caching
date: 2020-04-01 21:13:00
comment_id: 73
categories: [Data Systems, System Design]
tags: [Cache]
---

Cache helps making vastly `better use of the resources you already have`. Caches take advantage of the locality of reference principle: `recently requested data is likely to be requested again.`

Cache is like a short-term memory: it has a limited amount of space, but is typically faster than the original data source and contains the most recently accessed items.

## Application server cache

Placing a cache `directly on a request layer` node enables the local storage of response data. Each time a request is made to the service, the node will quickly return local cached data if it exists. If it is not in the ache, the requesting node will query the data from disk. The cache on one request layer node could also be located both in `memory`(which is very fast) and on the `node's local disk`(faster than going to network storage).

### What happens when you expand this to many nodes?

If the request layer is expanded to multiple nodes, it’s still quite possible to have each node host its own cache. However, if your load balancer randomly `distributes requests across the nodes`, the same request will go to different nodes, thus `increasing cache misses`. `Two choices` for overcoming this hurdle are `global caches` and `distributed caches`.

## Content Distribution Network (CDN)

`CDNs` are a kind of cache that comes into play for `sites serving large amounts of static media`. In a typical CDN setup, a `request will first ask the CDN for a piece of static media`; the `CDN will serve that content if it has it locally available`. If it `isn’t available`, the CDN will `query the back- end servers` for the file, cache it locally, and serve it to the requesting user.

If the system we are building isn’t yet large enough to have its own CDN, we can ease a future transition by `serving the static media off a separate subdomain` (e.g. static.yourservice.com (http://static.yourservice.com)) using a lightweight HTTP server like Nginx, and cut-over the DNS from your servers to a CDN later.

## Cache Invalidation

If the `data is modified` in the database, it should be `invalidated in the cache`; if not, this can cause inconsistent application behavior.

- **Write through cache**
  - Under this scheme, data is `written` into the `cache` and the `corresponding database` at the same time. The cached data allows for fast retrieval and, since the same data gets written in the permanent storage, we will have complete data consistency between the cache and the storage. Also, this scheme ensures that nothing will get lost in case of a crash, power failure, or other system disruptions.
  - Although, write through minimizes the risk of data loss, since every write operation must be done twice before returning success to the client, this scheme has the `disadvantage` of `higher latency for write operations`.
- **Write around cache**
  - Data is `written` `directly` to `permanent storage`, bypassing the cache. This can reduce the cache being flooded with write operations that will not subsequently be re-read, but has the disadvantage that a read request for recently written data will `create a “cache miss”` and must be `read from slower back-end storage and experience higher latency`.
- **Write back cache**
  - Under this scheme, data is `written to cache alone` and completion is immediately confirmed to the client. The `write to the permanent storag`e is done `after` `specified intervals or under certain conditions`. This results in `low latency` and `high throughput for write`- intensive applications, however, this speed `comes with the risk of data loss` in case of a crash or other adverse event because the only copy of the written data is in the cache.

## Cache eviction policies

- `First In First Out (FIFO)`: The cache evicts the first block accessed first without any regard to how often or how many times it was accessed before.
- `Last In First Out (LIFO)`: The cache evicts the block accessed most recently first without any regard to how often or how many times it recently first without any regard to how often or how many times it was accessed before.
- `Least Recently Used (LRU)`: Discards the least recently used items first.
- `Most Recently Used (MRU)`: Discards, in contrast to LRU, the most recently used items first.
- `Least Frequently Used (LFU)`: Counts how often an item is needed. Those that are used least often are discarded first.
- `Random Replacement (RR)`: Randomly selects a candidate item and discards it to make space when necessary.

#### Reference

<https://www.educative.io/courses/grokking-the-system-design-interview/3j6NnJrpp5p>